<md-toolbar class="md-theme-indigo">
	<h1 class="md-toolbar-tools">Patterns</h1>
</md-toolbar>

<section class="md-padding max-sized">


  <article class="md-padding">
    <h2>Dependency injection</h2>
    
    
    <h3>voordat ik uit kan leggen wat Dependency injection is, gaan </h3>
    <p>
  
    <p>
        Dependency injection is een van de meest voorkomende implementaties van IOC*. De verantwoordelijkheid voor het aanmaken van 
        een object binnen een ander object, wordt verplaatst door een instantie van het nieuwe object in het bestaande object te injecteren. Dit kan op 3 manieren:
        

    </p>

    <ul flex-sm>
        <li>Via een <b>constructor</b></li>
        <li>Via een setter van een <b>property</b></li>
        <li>Via een <b>methode</b></li>
    </ul>


		
        </div>
        <div class="col-md-4 text-center">
          
        </div>
    </div>
  
    <p class="top-buffer">
        In de opdracht over testen werd gebruik gemaakt van de klasse 
        <a target="_blank"  href="https://github.com/Avans/Prog6_TheWizard/blob/master/Wizard/Tovenaar.cs">Tovenaar</a> 
        met een referentie naar een <b>Tovestaf</b> en een <b>Kookpot</b>.
        E was geen toegang naar het object <b>Koookpot</b> mogelijk omdat deze private was en aangemaakt werd in de constructor van de tovenaar. 
        Via de regels van Dependency Injection kunnen we de verantwoordelijkheid voor het aanmaken van deze objecten verplaatsen.
        Er zijn 3 manieren om het ge&iuml;nitialiseerde object (kookpot) in de tovenaar te krijgen.
    </p>
    
    <md-card>
      <md-card-content>
         <b>Constructor</b>
         <pre class="prettyprint linenums">
public MainViewModel(ICarRepository carRepository)
{
    this._carRepository = carRepository;
    var cars = carRepository.GetAllCars().Where(c =&gt; !c.Actief).ToList();
    this.MyCars = new ObservableCollection&lt;CarVM&gt;(cars.Select(c =&gt; new CarVM(c)));
}</pre>
      </md-card-content>
    </md-card>
            
    <md-card>
      <md-card-content>
        <b>Property Setter</b>
    
        <pre class="prettyprint linenums">
MainViewModel mvm = new MainViewModel();
mvm.CarRepository = new DummyCarRepository();</pre>
      </md-card-content>
    </md-card>
    
    <md-card>
      <md-card-content>
        <b>Method</b>
        <pre class="prettyprint linenums">
public void SetRepository(ICarRepository carRepository)
{
    this._carRepository = carRepository;
}
</pre>
      </md-card-content>
    </md-card>
            

    <h3>Dependency Injection in .NET </h3>

	<p>
		Het basis principe achter Dependency injection is de verantwoordelijkheid voor het aanmaken van objecten verhuizen naar een andere plek. 
		Het .NET framework biedt hier een aantal oplossingen voor. Bijvoorbeeld het <strong>Managed Extensibility Framework (MEF)</strong>.
		Het MEF bestaat uit 3 onderdelen. 
		<ul>
			<li>Container</li>
			<li>Imports</li>
			<li>Exports</li>
		</ul>

	</p>
        </div>

    <div class="bs-callout bs-callout-info  row">
        <div class="col-md-6">
         
            
            <pre class="prettyprint linenums">
using System.ComponentModel.Composition;
using System.ComponentModel.Composition.Hosting;</pre>
            
            
        </div>
        <div class="col-md-6 text-center">
            <img src="onderwerp/patterns/img/composition.png" alt="composition" />
        </div>
    </div>

    
    <div class="row">
        

    <h3>Container</h3> 
        
    <p>
        De container verzamelt alle klassen met een <strong>Export</strong> attribuut in de vorm van een catalog.
        Deze <strong>AssemblyCatalog</strong> kun je vullen met behulp van de <strong>Assembly</strong> class waarmee je door alle assemblies in
        je project kunt zoeken naar klasse met een Export attribuut. Deze lijst (catalogus) geef je mee aan een 
        <strong>CompositionContainer</strong>
    </p>
    
    <p>
        Vervolgens kun je via een <strong>ComposeParts</strong> methode een object vullen met de ge&iuml;mporteerde classes.
    </p>
  
    <pre class="prettyprint linenums">
var catalog = new AssemblyCatalog(Assembly.GetAssembly(typeof(IInstrument)));
var container = new CompositionContainer(catalog);
var rockBand = new RockBand();
container.ComposeParts(rockBand);</pre>
                 

     <div class="col-md-6">
            
        <h3>Import</h3>

        <pre class="prettyprint linenums">
[ImportMany(typeof(IInstrument))]</pre>
          
        <p>
           Het ImportMany attribuut wordt op een property van het type List geplaatst. 
            Indien de klasse waarin deze property zich bevindt
            'gecomposed' wordt door de CompositionContainer, worden alle types in de catalogus die overeenkomen met het 
            meegegeven type aan de export, in deze lijst ge&iuml;njecteerd.  
        </p>
        
        <p>
           Naast het Attribuut <strong>ImportMany</strong> kun je ook gebruik maken van het <strong>Import</strong> 
            attribuut om een object te initialiseren wat geen lijst is. 
        </p>

    </div>
    <div class="col-md-6">
            
        <h3>Export</h3>
                     <pre class="prettyprint linenums">
[Export(typeof(IInstrument))]</pre>
                     

        <p>
             Het Export attribuut geeft aan dat een klasse beschikbaar moet worden voor de catalogus.
             In het voorbeeld wordt aangegeven dat de klasse waarop het attribuut zich bevindt, als een <strong>IInstrument</strong>
             in de catalogus komt te staan.
        </p>

    </div>

    <h4>Dependency Injection Frameworks</h4>
    
    <p>
        Naast het <strong>MEF</strong> wat onderdeel is van het .NET framework zijn er nog meer Dependency Injection Frameworks. 
        Te veel om op te noemen! 
    </p>

    <h3>Bronnen</h3>
    <ul>
        <li><a target="_blank" href="http://tutorials.jenkov.com/dependency-injection/the-opportunities-missed-by-annotation-based-dependency-injection.html">http://tutorials.jenkov.com/dependency-injection/the-opportunities-missed-by-annotation-based-dependency-injection.html</a></li>
    </ul>
    
            
    <!-- Deze regel javascript hebben we nodig voor het 'prettifyen' van onze code snippits -->
    <script>
        
      !function ($) {
        $(function(){
          window.prettyPrint && prettyPrint()   
        })
      }(window.jQuery)
      
    </script>
    
	  
	  http://www.codeproject.com/Tips/572761/Generic-repository-pattern-using-EF-with-Dependenc
  </article>
</section>